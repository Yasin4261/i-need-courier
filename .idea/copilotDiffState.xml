<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CHANGELOG.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CHANGELOG.md" />
              <option name="originalContent" value="# Changelog&#10;&#10;All notable changes to the I Need Courier project will be documented in this file.&#10;&#10;The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),&#10;and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).&#10;&#10;---&#10;&#10;## [1.4.0] - 2025-12-06&#10;&#10;### Added&#10;- **Order Assignment &amp; Delivery System**&#10;  - FIFO queue-based automatic order assignment&#10;  - On-duty courier management with real-time tracking&#10;  - 4-minute timeout with automatic reassignment&#10;  - WebSocket notifications for real-time updates&#10;  &#10;- **Courier Assignment Endpoints**&#10;  - GET `/api/v1/courier/assignments/pending` – Get pending assignments&#10;  - POST `/api/v1/courier/assignments/{id}/accept` – Accept assignment&#10;  - POST `/api/v1/courier/assignments/{id}/reject` – Reject assignment&#10;  &#10;- **Courier Delivery Endpoints**&#10;  - POST `/api/v1/courier/orders/{id}/pickup` – Mark order as picked up&#10;  - POST `/api/v1/courier/orders/{id}/start-delivery` – Start delivery (in transit)&#10;  - POST `/api/v1/courier/orders/{id}/complete` – Complete delivery&#10;  &#10;- **Database Schema**&#10;  - `on_duty_couriers` table for FIFO queue management&#10;  - `order_assignments` table for assignment tracking&#10;  - Assignment status enum (PENDING, ACCEPTED, REJECTED, TIMEOUT)&#10;  - Assignment type enum (AUTO, REASSIGNMENT, MANUAL)&#10;  &#10;- **Custom Exception System**&#10;  - `NoCourierAvailableException` (503) - No courier available&#10;  - `AssignmentNotFoundException` (404) - Assignment not found&#10;  - `AssignmentNotOwnedException` (403) - Unauthorized access&#10;  - `AssignmentExpiredException` (410) - Assignment timeout&#10;  - `InvalidAssignmentStatusException` (409) - Invalid status&#10;  &#10;- **Documentation**&#10;  - `COURIER_ORDER_FLOW.md` - Complete delivery flow guide&#10;  - `WHY_START_DELIVERY_EXISTS.md` - Design explanation&#10;  - `DEBUG_PICKUP_ISSUE.md` - Troubleshooting guide&#10;  - `PROJECT_STRUCTURE.md` - Project organization&#10;  - 15+ comprehensive documentation files&#10;&#10;### Changed&#10;- Improved logging with DEBUG, INFO, ERROR levels&#10;- Enhanced exception handling with proper HTTP status codes&#10;- Reorganized project structure (docs/, scripts/tests/)&#10;- Updated Postman collections with 30+ requests&#10;&#10;### Fixed&#10;- Order.courier NULL issue in acceptAssignment&#10;- &quot;Bu sipariş size atanmamış&quot; error in pickup&#10;- 415 Unsupported Media Type error&#10;- Duplicate assignment creation&#10;- Timeout filter in pending assignments query&#10;- RuntimeException to Custom Exceptions refactoring&#10;&#10;### Deprecated&#10;- None&#10;&#10;### Removed&#10;- 8 obsolete files (fix-flyway.sh, migration.sh, etc.)&#10;- Old/unused test scripts from root directory&#10;&#10;### Security&#10;- Enhanced authorization checks in all endpoints&#10;- Proper ownership verification&#10;- Status-based access control&#10;&#10;---&#10;&#10;## [1.3.0] - 2025-11-14&#10;&#10;### Added&#10;- Courier Shift Management system&#10;  - GET `/api/v1/courier/shifts/templates` – List shift templates&#10;  - POST `/api/v1/courier/shifts/reserve` – Reserve a shift&#10;  - GET `/api/v1/courier/shifts/upcoming` – Upcoming shifts&#10;  - GET `/api/v1/courier/shifts/my-shifts` – List my shifts (with status filter)&#10;  - GET `/api/v1/courier/shifts/active` – Active shift&#10;  - POST `/api/v1/courier/shifts/{id}/check-in` – Check-in&#10;  - POST `/api/v1/courier/shifts/{id}/check-out` – Check-out&#10;  - DELETE `/api/v1/courier/shifts/{id}/cancel` – Cancel reservation&#10;- Bash test script `test-shift-yasin.sh` with auto-cancel and parameters (SHIFT_DATE, TEMPLATE_INDEX)&#10;- Postman collections and shift testing guide under docs/guides&#10;&#10;### Changed&#10;- Global exception handler improvements for method/media type errors&#10;- Security enhancements: added JwtAuthenticationEntryPoint and JwtAccessDeniedHandler&#10;&#10;### Fixed&#10;- PostgreSQL enum mismatch on `shifts.shift_role` and `shifts.status` by converting to VARCHAR (manual SQL + V13 migration file)&#10;&#10;---&#10;&#10;## [1.2.0] - 2025-11-07&#10;&#10;### Added&#10;- **Business Order Management System**: Complete CRUD operations for orders&#10;- **8 New API Endpoints**: Full order management functionality&#10;  - POST `/api/v1/business/orders` - Create order&#10;  - GET `/api/v1/business/orders` - List all orders&#10;  - GET `/api/v1/business/orders?status=X` - Filter by status&#10;  - GET `/api/v1/business/orders/{id}` - Get order details&#10;  - PUT `/api/v1/business/orders/{id}` - Update order&#10;  - DELETE `/api/v1/business/orders/{id}` - Delete order&#10;  - POST `/api/v1/business/orders/{id}/cancel` - Cancel order&#10;  - GET `/api/v1/business/orders/statistics` - Get statistics&#10;- **Order Entity**: New Order model with full order lifecycle support&#10;- **Order Enums**: OrderStatus, OrderPriority, PaymentType&#10;- **BusinessOrderService**: Service layer for order operations&#10;- **OrderRepository**: Custom queries for order management&#10;- **Order DTOs**: OrderCreateRequest, OrderUpdateRequest, OrderResponse&#10;- **Auto-generated Order Numbers**: Format ORD-YYYYMMDD-XXX&#10;- **Order Statistics Endpoint**: Real-time order statistics&#10;- **Status-based Filtering**: Filter orders by status&#10;- **Business Ownership Verification**: Users can only access their own orders&#10;- **PostgreSQL Enum Support**: Fixed enum type mapping with @JdbcTypeCode&#10;- **Comprehensive Test Suite**: &#10;  - `BUSINESS_ORDER_CURL_TESTS.md` - Complete curl examples&#10;  - `BUSINESS_ORDER_IMPLEMENTATION.md` - Implementation guide&#10;  - `POSTGRES_ENUM_FIX.md` - Enum fix documentation&#10;  - `TEST_README.md` - Quick start guide&#10;  - Postman collection with 17 requests&#10;  - Python automated test script&#10;  - Bash test script for quick validation&#10;&#10;### Changed&#10;- **Architecture**: Implemented Clean Layered Architecture&#10;- **Package Structure**: Added separate `business` package for business features&#10;- **Security Config**: Updated to allow business endpoints (temporary)&#10;- **Hibernate Config**: Added PostgreSQL dialect configuration&#10;- **Application Properties**: Enhanced JPA/Hibernate settings&#10;&#10;### Fixed&#10;- **PostgreSQL Enum Type Mismatch**: Fixed payment_type, order_status, order_priority casting&#10;- **Hibernate Enum Mapping**: Added @JdbcTypeCode for proper enum handling&#10;- **Security Configuration**: Fixed 403 Forbidden on business endpoints&#10;- **JPA Configuration**: Resolved LOB handling issues&#10;&#10;### Security&#10;- **JWT Authorization**: All order endpoints require valid JWT token&#10;- **Ownership Validation**: Business can only access their own orders&#10;- **Status-based Operations**: PENDING orders can be updated/deleted, ASSIGNED can be cancelled&#10;- **Authorization Checks**: Every operation validates ownership&#10;&#10;### Technical&#10;- **Clean Layered Architecture**: Controller → Service → Repository → Model&#10;- **SOLID Principles**: Interface segregation, dependency injection&#10;- **Repository Pattern**: Custom queries and data access abstraction&#10;- **DTO Pattern**: Separate request/response models&#10;- **Exception Handling**: Custom exceptions with global handler&#10;- **Validation**: Input validation with Jakarta validation&#10;&#10;### Documentation&#10;- Added detailed curl test guide with all endpoints&#10;- Added implementation documentation&#10;- Added PostgreSQL enum fix documentation&#10;- Added Postman collection for easy testing&#10;- Added Python and Bash test scripts&#10;- Updated README with new features&#10;- Updated VERSION.md with v1.2.0&#10;&#10;---&#10;&#10;## [1.1.0] - 2025-11-07&#10;&#10;### Added&#10;- **Unified Authentication System**: Single login endpoint for all user types&#10;- **Automatic User Type Detection**: System automatically identifies Courier vs Business users&#10;- **Courier Registration API**: New endpoint for courier self-registration&#10;- **Business Registration API**: New endpoint for business self-registration&#10;- **JWT Role-based Authorization**: Tokens now include user type (COURIER/BUSINESS)&#10;- **Status-based Access Control**: Only active users can login&#10;- **Test Documentation**: Added comprehensive test guides and results&#10;- Database migration V10: Convert business status to VARCHAR&#10;- Database migration V11: Convert courier status to VARCHAR&#10;&#10;### Changed&#10;- **Courier Model**: Updated status column from enum to VARCHAR(20)&#10;- **Business Model**: Updated status column from enum to VARCHAR(20)&#10;- **Login Response**: Now includes userType and status fields&#10;- **JWT Token Structure**: Enhanced with role information&#10;&#10;### Fixed&#10;- Courier status enum type mismatch causing registration failures&#10;- Business status enum type mismatch&#10;- Database constraint issues with enum types&#10;- Column definition conflicts in entity models&#10;&#10;### Security&#10;- Implemented BCrypt password hashing for all user types&#10;- Added JWT token validation with role checking&#10;- Implemented status-based login restrictions&#10;&#10;### Documentation&#10;- Added `docs/guides/TEST_LOGIN_GUIDE.md` - Complete testing guide with examples&#10;- Added `docs/guides/TEST_RESULTS.md` - Detailed test results and API responses&#10;- Added `docs/INDEX.md` - Documentation index and navigation&#10;- Added `VERSION.md` - Version history and roadmap&#10;- Updated API documentation with new endpoints&#10;&#10;---&#10;&#10;## [1.0.0] - 2025-10-31&#10;&#10;### Added&#10;- Initial project setup with Spring Boot 3.5.4&#10;- PostgreSQL database integration&#10;- Redis caching support&#10;- Apache Kafka event streaming&#10;- Docker containerization with docker-compose&#10;- Nginx reverse proxy configuration&#10;- Flyway database migrations (V1-V9)&#10;- Basic entity models (User, Business, Courier, Order, Delivery)&#10;- Health check endpoints with Spring Boot Actuator&#10;- Swagger/OpenAPI documentation&#10;- JWT authentication infrastructure&#10;- Security configuration with Spring Security&#10;- CORS configuration&#10;- Database connection pooling with HikariCP&#10;&#10;### Infrastructure&#10;- Docker Compose orchestration&#10;- PostgreSQL 15.4 container&#10;- Redis 7.2 container&#10;- Apache Kafka with Zookeeper&#10;- Development and production profiles&#10;&#10;### Documentation&#10;- Project README&#10;- Database design documentation&#10;- API documentation structure&#10;- Deployment guide&#10;- Contributing guidelines&#10;- Git workflow documentation&#10;&#10;---&#10;&#10;## Version Comparison&#10;&#10;### v1.1.0 vs v1.0.0&#10;&#10;**New Features:**&#10;-  Unified login system (1 endpoint vs 2 separate)&#10;-  Auto user type detection&#10;-  Enhanced JWT tokens with roles&#10;-  Courier self-registration&#10;-  Business self-registration&#10;&#10;**Improvements:**&#10;-  Better database schema (VARCHAR vs ENUM)&#10;-  More flexible user status management&#10;-  Improved error handling&#10;&#10;**Bug Fixes:**&#10;-  Enum type mismatches resolved&#10;-  Registration failures fixed&#10;-  Database constraints corrected&#10;&#10;---&#10;&#10;## Migration Guide&#10;&#10;### From v1.0.0 to v1.1.0&#10;&#10;#### Database Changes&#10;Run the following migrations automatically with Flyway:&#10;- V10__Convert_business_status_to_varchar.sql&#10;- V11__Convert_courier_status_to_varchar.sql&#10;&#10;#### API Changes&#10;&#10;**Old Login (v1.0.0):**&#10;```&#10;POST /api/v1/courier/login&#10;POST /api/v1/business/login&#10;```&#10;&#10;**New Login (v1.1.0):**&#10;```&#10;POST /api/v1/auth/login&#10;```&#10;&#10;**Response Format Change:**&#10;```json&#10;// v1.0.0&#10;{&#10;  &quot;token&quot;: &quot;...&quot;,&#10;  &quot;userId&quot;: 1,&#10;  &quot;email&quot;: &quot;...&quot;&#10;}&#10;&#10;// v1.1.0&#10;{&#10;  &quot;token&quot;: &quot;...&quot;,&#10;  &quot;userId&quot;: 1,&#10;  &quot;email&quot;: &quot;...&quot;,&#10;  &quot;userType&quot;: &quot;COURIER&quot;,  // NEW&#10;  &quot;status&quot;: &quot;ONLINE&quot;      // NEW&#10;}&#10;```&#10;&#10;#### Breaking Changes&#10;- None - Old endpoints are deprecated but still functional&#10;&#10;---&#10;&#10;## Deprecation Notice&#10;&#10;### Deprecated in v1.1.0&#10;The following endpoints are deprecated and will be removed in v2.0.0:&#10;- `POST /api/v1/courier/login` (Use `/api/v1/auth/login` instead)&#10;- `POST /api/v1/business/login` (Use `/api/v1/auth/login` instead)&#10;&#10;---&#10;&#10;## Links&#10;&#10;- [Version History](VERSION.md)&#10;- [API Documentation](docs/api/API.md)&#10;- [Contributing Guide](docs/guides/CONTRIBUTING.md)&#10;- [GitHub Repository](https://github.com/YOUR_USERNAME/i-need-courier)&#10;&#10;---&#10;&#10;[1.1.0]: https://github.com/YOUR_USERNAME/i-need-courier/compare/v1.0.0...v1.1.0&#10;[1.0.0]: https://github.com/YOUR_USERNAME/i-need-courier/releases/tag/v1.0.0&#10;" />
              <option name="updatedContent" value="# Changelog&#10;&#10;All notable changes to the I Need Courier project will be documented in this file.&#10;&#10;The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),&#10;and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).&#10;&#10;---&#10;&#10;## [1.9.0] - 2025-12-06&#10;&#10;### Added&#10;- **Project Organization &amp; Documentation**&#10;  - `PROJECT_STRUCTURE.md` - Complete project organization guide&#10;  - `COURIER_ORDER_FLOW.md` - Detailed delivery flow documentation&#10;  - `WHY_START_DELIVERY_EXISTS.md` - Design decision explanations&#10;  - `DEBUG_PICKUP_ISSUE.md` - Comprehensive troubleshooting guide&#10;  - Organized documentation into `docs/reports/`, `docs/fixes/`, `docs/flows/`&#10;  - Test scripts moved to `scripts/tests/`&#10;  - 15+ documentation files created/reorganized&#10;&#10;### Changed&#10;- Reorganized 26 files from root directory into proper subdirectories&#10;- Updated all documentation with current system state&#10;- Enhanced README with clear project structure&#10;&#10;### Removed&#10;- 8 obsolete files (fix-flyway.sh, flyway-repair-guide.sh, migration.sh, github-push.sh, etc.)&#10;- Old/unused test scripts from root directory&#10;- Redundant documentation files&#10;&#10;---&#10;&#10;## [1.8.0] - 2025-12-06&#10;&#10;### Added&#10;- **WebSocket &amp; Real-time Notifications**&#10;  - WebSocket configuration for real-time communication&#10;  - `WebSocketNotificationService` for assignment notifications&#10;  - Real-time order assignment notifications to couriers&#10;  - STOMP messaging protocol support&#10;  - `/topic/assignments/{courierId}` subscription endpoint&#10;&#10;### Changed&#10;- Enhanced assignment flow with instant courier notifications&#10;- Improved user experience with real-time updates&#10;&#10;---&#10;&#10;## [1.7.0] - 2025-12-06&#10;&#10;### Added&#10;- **Custom Exception System**&#10;  - `NoCourierAvailableException` (503) - No courier available for assignment&#10;  - `AssignmentNotFoundException` (404) - Assignment not found&#10;  - `AssignmentNotOwnedException` (403) - Unauthorized assignment access&#10;  - `AssignmentExpiredException` (410) - Assignment timeout&#10;  - `InvalidAssignmentStatusException` (409) - Invalid status transition&#10;  &#10;- **Enhanced Logging System**&#10;  - DEBUG level logs for development&#10;  - INFO level logs for operations&#10;  - ERROR level logs with detailed context&#10;  - Request/Response logging for all endpoints&#10;  - Assignment flow tracking&#10;&#10;### Changed&#10;- Replaced generic `RuntimeException` with specific custom exceptions&#10;- Improved HTTP status code accuracy (403, 404, 410, 503 instead of 500)&#10;- Enhanced error messages with detailed context&#10;- Better exception handling in GlobalExceptionHandler&#10;&#10;### Fixed&#10;- Proper HTTP status codes for different error scenarios&#10;- Improved debugging with detailed error context&#10;&#10;---&#10;&#10;## [1.6.0] - 2025-12-06&#10;&#10;### Added&#10;- **Delivery Flow System**&#10;  - POST `/api/v1/courier/orders/{id}/pickup` – Mark order as picked up&#10;  - POST `/api/v1/courier/orders/{id}/start-delivery` – Start delivery (in transit)&#10;  - POST `/api/v1/courier/orders/{id}/complete` – Complete delivery with notes and collection amount&#10;  - Complete order status workflow (ASSIGNED → PICKED_UP → IN_TRANSIT → DELIVERED)&#10;  - Optional notes and collection amount tracking&#10;  - Flexible parameter handling (query params, form data, JSON)&#10;&#10;### Changed&#10;- Added `consumes = {&quot;*/*&quot;}` for better content-type support&#10;- Enhanced CourierOrderController with detailed logging&#10;- Improved parameter flexibility (@RequestParam instead of @RequestBody)&#10;&#10;### Fixed&#10;- &quot;Bu sipariş size atanmamış&quot; error in pickup endpoint&#10;- Order.courier NULL issue in acceptAssignment&#10;- 415 Unsupported Media Type error&#10;- Proper courier ownership verification&#10;&#10;---&#10;&#10;## [1.5.0] - 2025-12-06&#10;&#10;### Added&#10;- **Order Assignment System**&#10;  - FIFO queue-based automatic assignment algorithm&#10;  - GET `/api/v1/courier/assignments/pending` – Get pending assignments&#10;  - POST `/api/v1/courier/assignments/{id}/accept` – Accept assignment&#10;  - POST `/api/v1/courier/assignments/{id}/reject` – Reject assignment with reason&#10;  - 4-minute timeout mechanism with automatic reassignment&#10;  - Assignment history tracking&#10;  - `CourierAssignmentController` with 3 endpoints&#10;  &#10;- **Database Schema**&#10;  - `order_assignments` table for assignment tracking&#10;  - Assignment status enum (PENDING, ACCEPTED, REJECTED, TIMEOUT)&#10;  - Assignment type enum (AUTO, REASSIGNMENT, MANUAL)&#10;  - Timestamp tracking (assigned_at, response_at, timeout_at)&#10;  &#10;- **Assignment Service**&#10;  - `OrderAssignmentService` with auto-assignment logic&#10;  - Timeout checking scheduled task&#10;  - Automatic reassignment on timeout/reject&#10;  - Queue management integration&#10;&#10;### Changed&#10;- Business order creation now triggers automatic assignment&#10;- Enhanced order lifecycle with assignment tracking&#10;&#10;### Fixed&#10;- Duplicate assignment creation prevention&#10;- Timeout filter in pending assignments query&#10;- Assignment status transition validation&#10;&#10;---&#10;&#10;## [1.4.0] - 2025-12-06&#10;&#10;### Added&#10;- **On-Duty Courier Management System**&#10;  - POST `/api/v1/courier/shifts/{id}/check-in` – Check-in to shift (become on-duty)&#10;  - POST `/api/v1/courier/shifts/check-out` – Check-out from shift (go off-duty)&#10;  - FIFO queue management for on-duty couriers&#10;  - Real-time on-duty status tracking&#10;  - `OnDutyService` with queue operations&#10;  &#10;- **Database Schema**&#10;  - `on_duty_couriers` table with FIFO queue support&#10;  - Created timestamp and on_duty_since tracking&#10;  - Source tracking (shift vs manual)&#10;  - Automatic cleanup on check-out&#10;&#10;### Changed&#10;- Enhanced shift system with on-duty integration&#10;- ShiftService updated with check-in/check-out logic&#10;&#10;### Security&#10;- Enhanced authorization checks in all endpoints&#10;- Proper ownership verification&#10;- Status-based access control&#10;&#10;---&#10;&#10;## [1.3.0] - 2025-11-14&#10;&#10;### Added&#10;- Courier Shift Management system&#10;  - GET `/api/v1/courier/shifts/templates` – List shift templates&#10;  - POST `/api/v1/courier/shifts/reserve` – Reserve a shift&#10;  - GET `/api/v1/courier/shifts/upcoming` – Upcoming shifts&#10;  - GET `/api/v1/courier/shifts/my-shifts` – List my shifts (with status filter)&#10;  - GET `/api/v1/courier/shifts/active` – Active shift&#10;  - POST `/api/v1/courier/shifts/{id}/check-in` – Check-in&#10;  - POST `/api/v1/courier/shifts/{id}/check-out` – Check-out&#10;  - DELETE `/api/v1/courier/shifts/{id}/cancel` – Cancel reservation&#10;- Bash test script `test-shift-yasin.sh` with auto-cancel and parameters (SHIFT_DATE, TEMPLATE_INDEX)&#10;- Postman collections and shift testing guide under docs/guides&#10;&#10;### Changed&#10;- Global exception handler improvements for method/media type errors&#10;- Security enhancements: added JwtAuthenticationEntryPoint and JwtAccessDeniedHandler&#10;&#10;### Fixed&#10;- PostgreSQL enum mismatch on `shifts.shift_role` and `shifts.status` by converting to VARCHAR (manual SQL + V13 migration file)&#10;&#10;---&#10;&#10;## [1.2.0] - 2025-11-07&#10;&#10;### Added&#10;- **Business Order Management System**: Complete CRUD operations for orders&#10;- **8 New API Endpoints**: Full order management functionality&#10;  - POST `/api/v1/business/orders` - Create order&#10;  - GET `/api/v1/business/orders` - List all orders&#10;  - GET `/api/v1/business/orders?status=X` - Filter by status&#10;  - GET `/api/v1/business/orders/{id}` - Get order details&#10;  - PUT `/api/v1/business/orders/{id}` - Update order&#10;  - DELETE `/api/v1/business/orders/{id}` - Delete order&#10;  - POST `/api/v1/business/orders/{id}/cancel` - Cancel order&#10;  - GET `/api/v1/business/orders/statistics` - Get statistics&#10;- **Order Entity**: New Order model with full order lifecycle support&#10;- **Order Enums**: OrderStatus, OrderPriority, PaymentType&#10;- **BusinessOrderService**: Service layer for order operations&#10;- **OrderRepository**: Custom queries for order management&#10;- **Order DTOs**: OrderCreateRequest, OrderUpdateRequest, OrderResponse&#10;- **Auto-generated Order Numbers**: Format ORD-YYYYMMDD-XXX&#10;- **Order Statistics Endpoint**: Real-time order statistics&#10;- **Status-based Filtering**: Filter orders by status&#10;- **Business Ownership Verification**: Users can only access their own orders&#10;- **PostgreSQL Enum Support**: Fixed enum type mapping with @JdbcTypeCode&#10;- **Comprehensive Test Suite**: &#10;  - `BUSINESS_ORDER_CURL_TESTS.md` - Complete curl examples&#10;  - `BUSINESS_ORDER_IMPLEMENTATION.md` - Implementation guide&#10;  - `POSTGRES_ENUM_FIX.md` - Enum fix documentation&#10;  - `TEST_README.md` - Quick start guide&#10;  - Postman collection with 17 requests&#10;  - Python automated test script&#10;  - Bash test script for quick validation&#10;&#10;### Changed&#10;- **Architecture**: Implemented Clean Layered Architecture&#10;- **Package Structure**: Added separate `business` package for business features&#10;- **Security Config**: Updated to allow business endpoints (temporary)&#10;- **Hibernate Config**: Added PostgreSQL dialect configuration&#10;- **Application Properties**: Enhanced JPA/Hibernate settings&#10;&#10;### Fixed&#10;- **PostgreSQL Enum Type Mismatch**: Fixed payment_type, order_status, order_priority casting&#10;- **Hibernate Enum Mapping**: Added @JdbcTypeCode for proper enum handling&#10;- **Security Configuration**: Fixed 403 Forbidden on business endpoints&#10;- **JPA Configuration**: Resolved LOB handling issues&#10;&#10;### Security&#10;- **JWT Authorization**: All order endpoints require valid JWT token&#10;- **Ownership Validation**: Business can only access their own orders&#10;- **Status-based Operations**: PENDING orders can be updated/deleted, ASSIGNED can be cancelled&#10;- **Authorization Checks**: Every operation validates ownership&#10;&#10;### Technical&#10;- **Clean Layered Architecture**: Controller → Service → Repository → Model&#10;- **SOLID Principles**: Interface segregation, dependency injection&#10;- **Repository Pattern**: Custom queries and data access abstraction&#10;- **DTO Pattern**: Separate request/response models&#10;- **Exception Handling**: Custom exceptions with global handler&#10;- **Validation**: Input validation with Jakarta validation&#10;&#10;### Documentation&#10;- Added detailed curl test guide with all endpoints&#10;- Added implementation documentation&#10;- Added PostgreSQL enum fix documentation&#10;- Added Postman collection for easy testing&#10;- Added Python and Bash test scripts&#10;- Updated README with new features&#10;- Updated VERSION.md with v1.2.0&#10;&#10;---&#10;&#10;## [1.1.0] - 2025-11-07&#10;&#10;### Added&#10;- **Unified Authentication System**: Single login endpoint for all user types&#10;- **Automatic User Type Detection**: System automatically identifies Courier vs Business users&#10;- **Courier Registration API**: New endpoint for courier self-registration&#10;- **Business Registration API**: New endpoint for business self-registration&#10;- **JWT Role-based Authorization**: Tokens now include user type (COURIER/BUSINESS)&#10;- **Status-based Access Control**: Only active users can login&#10;- **Test Documentation**: Added comprehensive test guides and results&#10;- Database migration V10: Convert business status to VARCHAR&#10;- Database migration V11: Convert courier status to VARCHAR&#10;&#10;### Changed&#10;- **Courier Model**: Updated status column from enum to VARCHAR(20)&#10;- **Business Model**: Updated status column from enum to VARCHAR(20)&#10;- **Login Response**: Now includes userType and status fields&#10;- **JWT Token Structure**: Enhanced with role information&#10;&#10;### Fixed&#10;- Courier status enum type mismatch causing registration failures&#10;- Business status enum type mismatch&#10;- Database constraint issues with enum types&#10;- Column definition conflicts in entity models&#10;&#10;### Security&#10;- Implemented BCrypt password hashing for all user types&#10;- Added JWT token validation with role checking&#10;- Implemented status-based login restrictions&#10;&#10;### Documentation&#10;- Added `docs/guides/TEST_LOGIN_GUIDE.md` - Complete testing guide with examples&#10;- Added `docs/guides/TEST_RESULTS.md` - Detailed test results and API responses&#10;- Added `docs/INDEX.md` - Documentation index and navigation&#10;- Added `VERSION.md` - Version history and roadmap&#10;- Updated API documentation with new endpoints&#10;&#10;---&#10;&#10;## [1.0.0] - 2025-10-31&#10;&#10;### Added&#10;- Initial project setup with Spring Boot 3.5.4&#10;- PostgreSQL database integration&#10;- Redis caching support&#10;- Apache Kafka event streaming&#10;- Docker containerization with docker-compose&#10;- Nginx reverse proxy configuration&#10;- Flyway database migrations (V1-V9)&#10;- Basic entity models (User, Business, Courier, Order, Delivery)&#10;- Health check endpoints with Spring Boot Actuator&#10;- Swagger/OpenAPI documentation&#10;- JWT authentication infrastructure&#10;- Security configuration with Spring Security&#10;- CORS configuration&#10;- Database connection pooling with HikariCP&#10;&#10;### Infrastructure&#10;- Docker Compose orchestration&#10;- PostgreSQL 15.4 container&#10;- Redis 7.2 container&#10;- Apache Kafka with Zookeeper&#10;- Development and production profiles&#10;&#10;### Documentation&#10;- Project README&#10;- Database design documentation&#10;- API documentation structure&#10;- Deployment guide&#10;- Contributing guidelines&#10;- Git workflow documentation&#10;&#10;---&#10;&#10;## Version Comparison&#10;&#10;### v1.1.0 vs v1.0.0&#10;&#10;**New Features:**&#10;-  Unified login system (1 endpoint vs 2 separate)&#10;-  Auto user type detection&#10;-  Enhanced JWT tokens with roles&#10;-  Courier self-registration&#10;-  Business self-registration&#10;&#10;**Improvements:**&#10;-  Better database schema (VARCHAR vs ENUM)&#10;-  More flexible user status management&#10;-  Improved error handling&#10;&#10;**Bug Fixes:**&#10;-  Enum type mismatches resolved&#10;-  Registration failures fixed&#10;-  Database constraints corrected&#10;&#10;---&#10;&#10;## Migration Guide&#10;&#10;### From v1.0.0 to v1.1.0&#10;&#10;#### Database Changes&#10;Run the following migrations automatically with Flyway:&#10;- V10__Convert_business_status_to_varchar.sql&#10;- V11__Convert_courier_status_to_varchar.sql&#10;&#10;#### API Changes&#10;&#10;**Old Login (v1.0.0):**&#10;```&#10;POST /api/v1/courier/login&#10;POST /api/v1/business/login&#10;```&#10;&#10;**New Login (v1.1.0):**&#10;```&#10;POST /api/v1/auth/login&#10;```&#10;&#10;**Response Format Change:**&#10;```json&#10;// v1.0.0&#10;{&#10;  &quot;token&quot;: &quot;...&quot;,&#10;  &quot;userId&quot;: 1,&#10;  &quot;email&quot;: &quot;...&quot;&#10;}&#10;&#10;// v1.1.0&#10;{&#10;  &quot;token&quot;: &quot;...&quot;,&#10;  &quot;userId&quot;: 1,&#10;  &quot;email&quot;: &quot;...&quot;,&#10;  &quot;userType&quot;: &quot;COURIER&quot;,  // NEW&#10;  &quot;status&quot;: &quot;ONLINE&quot;      // NEW&#10;}&#10;```&#10;&#10;#### Breaking Changes&#10;- None - Old endpoints are deprecated but still functional&#10;&#10;---&#10;&#10;## Deprecation Notice&#10;&#10;### Deprecated in v1.1.0&#10;The following endpoints are deprecated and will be removed in v2.0.0:&#10;- `POST /api/v1/courier/login` (Use `/api/v1/auth/login` instead)&#10;- `POST /api/v1/business/login` (Use `/api/v1/auth/login` instead)&#10;&#10;---&#10;&#10;## Links&#10;&#10;- [Version History](VERSION.md)&#10;- [API Documentation](docs/api/API.md)&#10;- [Contributing Guide](docs/guides/CONTRIBUTING.md)&#10;- [GitHub Repository](https://github.com/YOUR_USERNAME/i-need-courier)&#10;&#10;---&#10;&#10;[1.1.0]: https://github.com/YOUR_USERNAME/i-need-courier/compare/v1.0.0...v1.1.0&#10;[1.0.0]: https://github.com/YOUR_USERNAME/i-need-courier/releases/tag/v1.0.0&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/api/demo/controller/CourierAssignmentController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/api/demo/controller/CourierAssignmentController.java" />
              <option name="originalContent" value="package com.api.demo.controller;&#10;&#10;import com.api.demo.dto.ApiResponse;&#10;import com.api.demo.model.OrderAssignment;&#10;import com.api.demo.service.OrderAssignmentService;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.security.core.Authentication;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.stream.Collectors;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/v1/courier/assignments&quot;)&#10;public class CourierAssignmentController {&#10;&#10;    private final OrderAssignmentService orderAssignmentService;&#10;&#10;    public CourierAssignmentController(OrderAssignmentService orderAssignmentService) {&#10;        this.orderAssignmentService = orderAssignmentService;&#10;    }&#10;&#10;    @GetMapping(&quot;/pending&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; getPendingAssignments(&#10;            Authentication authentication) {&#10;&#10;        Long courierId = extractCourierId(authentication);&#10;        List&lt;OrderAssignment&gt; assignments = orderAssignmentService.getPendingAssignments(courierId);&#10;&#10;        List&lt;Map&lt;String, Object&gt;&gt; response = assignments.stream().map(assignment -&gt; {&#10;            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();&#10;            map.put(&quot;assignmentId&quot;, assignment.getId());&#10;            map.put(&quot;orderId&quot;, assignment.getOrderId());&#10;            map.put(&quot;assignedAt&quot;, assignment.getAssignedAt());&#10;            map.put(&quot;timeoutAt&quot;, assignment.getTimeoutAt());&#10;            map.put(&quot;status&quot;, assignment.getStatus().toString());&#10;            &#10;            // Kalan süre bilgisi ekle (saniye cinsinden)&#10;            if (assignment.getTimeoutAt() != null) {&#10;                java.time.OffsetDateTime now = java.time.OffsetDateTime.now(java.time.ZoneOffset.UTC);&#10;                long remainingSeconds = java.time.Duration.between(now, assignment.getTimeoutAt()).getSeconds();&#10;                map.put(&quot;remainingSeconds&quot;, Math.max(0, remainingSeconds));&#10;                map.put(&quot;timeoutWarning&quot;, remainingSeconds &lt; 60 ? &quot;Süre dolmak üzere!&quot; : null);&#10;            }&#10;            &#10;            return map;&#10;        }).collect(Collectors.toList());&#10;&#10;        return ResponseEntity.ok(ApiResponse.success(response, &quot;Bekleyen atamalar&quot;));&#10;    }&#10;&#10;    @PostMapping(&quot;/{assignmentId}/accept&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; acceptAssignment(&#10;            Authentication authentication,&#10;            @PathVariable Long assignmentId) {&#10;&#10;        Long courierId = extractCourierId(authentication);&#10;        orderAssignmentService.acceptAssignment(assignmentId, courierId);&#10;&#10;        return ResponseEntity.ok(ApiResponse.success(null, &quot;Sipariş kabul edildi&quot;));&#10;    }&#10;&#10;    @PostMapping(&quot;/{assignmentId}/reject&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; rejectAssignment(&#10;            Authentication authentication,&#10;            @PathVariable Long assignmentId,&#10;            @RequestBody Map&lt;String, String&gt; request) {&#10;&#10;        Long courierId = extractCourierId(authentication);&#10;        String reason = request.getOrDefault(&quot;reason&quot;, &quot;Belirtilmedi&quot;);&#10;&#10;        orderAssignmentService.rejectAssignment(assignmentId, courierId, reason);&#10;&#10;        return ResponseEntity.ok(ApiResponse.success(null, &quot;Sipariş reddedildi, başka kuryeye atanıyor&quot;));&#10;    }&#10;&#10;    private Long extractCourierId(Authentication authentication) {&#10;        // Principal is userId (Long) set by JwtAuthenticationFilter&#10;        Object principal = authentication.getPrincipal();&#10;&#10;        if (principal instanceof Long) {&#10;            return (Long) principal;&#10;        } else if (principal instanceof Number) {&#10;            return ((Number) principal).longValue();&#10;        }&#10;&#10;        throw new IllegalStateException(&quot;Expected principal to be userId (Long), but got: &quot; +&#10;                                       (principal != null ? principal.getClass() : &quot;null&quot;));&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.api.demo.controller;&#10;&#10;import com.api.demo.dto.ApiResponse;&#10;import com.api.demo.model.OrderAssignment;&#10;import com.api.demo.service.OrderAssignmentService;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.security.core.Authentication;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.stream.Collectors;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/v1/courier/assignments&quot;)&#10;public class CourierAssignmentController {&#10;&#10;    private final OrderAssignmentService orderAssignmentService;&#10;&#10;    public CourierAssignmentController(OrderAssignmentService orderAssignmentService) {&#10;        this.orderAssignmentService = orderAssignmentService;&#10;    }&#10;&#10;    @GetMapping(&quot;/pending&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; getPendingAssignments(&#10;            Authentication authentication) {&#10;&#10;        Long courierId = extractCourierId(authentication);&#10;        List&lt;OrderAssignment&gt; assignments = orderAssignmentService.getPendingAssignments(courierId);&#10;&#10;        List&lt;Map&lt;String, Object&gt;&gt; response = assignments.stream().map(assignment -&gt; {&#10;            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();&#10;            map.put(&quot;assignmentId&quot;, assignment.getId());&#10;            map.put(&quot;orderId&quot;, assignment.getOrderId());&#10;            map.put(&quot;assignedAt&quot;, assignment.getAssignedAt());&#10;            map.put(&quot;timeoutAt&quot;, assignment.getTimeoutAt());&#10;            map.put(&quot;status&quot;, assignment.getStatus().toString());&#10;            &#10;            // Kalan süre bilgisi ekle (saniye cinsinden)&#10;            if (assignment.getTimeoutAt() != null) {&#10;                java.time.OffsetDateTime now = java.time.OffsetDateTime.now(java.time.ZoneOffset.UTC);&#10;                long remainingSeconds = java.time.Duration.between(now, assignment.getTimeoutAt()).getSeconds();&#10;                map.put(&quot;remainingSeconds&quot;, Math.max(0, remainingSeconds));&#10;                map.put(&quot;timeoutWarning&quot;, remainingSeconds &lt; 60 ? &quot;Süre dolmak üzere!&quot; : null);&#10;            }&#10;            &#10;            return map;&#10;        }).collect(Collectors.toList());&#10;&#10;        return ResponseEntity.ok(ApiResponse.success(response, &quot;Bekleyen atamalar&quot;));&#10;    }&#10;&#10;    @PostMapping(&quot;/{assignmentId}/accept&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; acceptAssignment(&#10;            Authentication authentication,&#10;            @PathVariable Long assignmentId) {&#10;&#10;        Long courierId = extractCourierId(authentication);&#10;        orderAssignmentService.acceptAssignment(assignmentId, courierId);&#10;&#10;        return ResponseEntity.ok(ApiResponse.success(null, &quot;Sipariş kabul edildi&quot;));&#10;    }&#10;&#10;    @PostMapping(&quot;/{assignmentId}/reject&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; rejectAssignment(&#10;            Authentication authentication,&#10;            @PathVariable Long assignmentId,&#10;            @RequestBody Map&lt;String, String&gt; request) {&#10;&#10;        Long courierId = extractCourierId(authentication);&#10;        String reason = request.getOrDefault(&quot;reason&quot;, &quot;Belirtilmedi&quot;);&#10;&#10;        orderAssignmentService.rejectAssignment(assignmentId, courierId, reason);&#10;&#10;        return ResponseEntity.ok(ApiResponse.success(null, &quot;Sipariş reddedildi, başka kuryeye atanıyor&quot;));&#10;    }&#10;&#10;    private Long extractCourierId(Authentication authentication) {&#10;        // Principal is userId (Long) set by JwtAuthenticationFilter&#10;        Object principal = authentication.getPrincipal();&#10;&#10;        if (principal instanceof Long) {&#10;            return (Long) principal;&#10;        } else if (principal instanceof Number) {&#10;            return ((Number) principal).longValue();&#10;        }&#10;&#10;        throw new IllegalStateException(&quot;Expected principal to be userId (Long), but got: &quot; +&#10;                                       (principal != null ? principal.getClass() : &quot;null&quot;));&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/api/demo/infrastructure/adapter/output/persistence/JdbcCourierRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/api/demo/infrastructure/adapter/output/persistence/JdbcCourierRepository.java" />
              <option name="originalContent" value="package com.api.demo.infrastructure.adapter.output.persistence;&#10;&#10;import com.api.demo.domain.model.Courier;&#10;import com.api.demo.domain.model.CourierStatus;&#10;import com.api.demo.domain.port.output.CourierRepository;&#10;import com.api.demo.domain.valueobject.Email;&#10;import com.api.demo.domain.valueobject.Password;&#10;import com.api.demo.domain.valueobject.Phone;&#10;import org.springframework.jdbc.core.JdbcTemplate;&#10;import org.springframework.jdbc.core.RowMapper;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.sql.Timestamp;&#10;import java.time.LocalDateTime;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public class JdbcCourierRepository implements CourierRepository {&#10;&#10;    private final JdbcTemplate jdbcTemplate;&#10;&#10;    public JdbcCourierRepository(JdbcTemplate jdbcTemplate) {&#10;        this.jdbcTemplate = jdbcTemplate;&#10;    }&#10;&#10;    private final RowMapper&lt;Courier&gt; courierRowMapper = (rs, rowNum) -&gt; {&#10;        return new Courier(&#10;            rs.getLong(&quot;id&quot;),&#10;            rs.getString(&quot;name&quot;),&#10;            new Email(rs.getString(&quot;email&quot;)),&#10;            new Phone(rs.getString(&quot;phone&quot;)),&#10;            new Password(rs.getString(&quot;password_hash&quot;)),&#10;            CourierStatus.valueOf(rs.getString(&quot;status&quot;)),&#10;            rs.getTimestamp(&quot;created_at&quot;).toLocalDateTime(),&#10;            rs.getTimestamp(&quot;last_login_at&quot;) != null ?&#10;                rs.getTimestamp(&quot;last_login_at&quot;).toLocalDateTime() : null&#10;        );&#10;    };&#10;&#10;    @Override&#10;    public Optional&lt;Courier&gt; findById(Long id) {&#10;        String sql = &quot;&quot;&quot;&#10;            SELECT id, name, email, phone, password_hash, status, created_at, last_login_at &#10;            FROM couriers &#10;            WHERE id = ?&#10;            &quot;&quot;&quot;;&#10;&#10;        return jdbcTemplate.query(sql, courierRowMapper, id)&#10;                .stream()&#10;                .findFirst();&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;Courier&gt; findByEmail(Email email) {&#10;        String sql = &quot;&quot;&quot;&#10;            SELECT id, name, email, phone, password_hash, status, created_at, last_login_at &#10;            FROM couriers &#10;            WHERE email = ?&#10;            &quot;&quot;&quot;;&#10;&#10;        try {&#10;            return jdbcTemplate.query(sql, courierRowMapper, email.getValue())&#10;                    .stream()&#10;                    .findFirst();&#10;        } catch (Exception e) {&#10;            // Log the error and return empty&#10;            System.err.println(&quot;Error finding courier by email: &quot; + e.getMessage());&#10;            return Optional.empty();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Courier save(Courier courier) {&#10;        if (courier.getId() == null) {&#10;            return insert(courier);&#10;        } else {&#10;            return update(courier);&#10;        }&#10;    }&#10;&#10;    private Courier insert(Courier courier) {&#10;        String sql = &quot;&quot;&quot;&#10;            INSERT INTO couriers (name, email, phone, password_hash, status, created_at) &#10;            VALUES (?, ?, ?, ?, CAST(? AS user_status), ?)&#10;            RETURNING id&#10;            &quot;&quot;&quot;;&#10;&#10;        Long generatedId = jdbcTemplate.queryForObject(sql, Long.class,&#10;            courier.getName(),&#10;            courier.getEmail().getValue(),&#10;            courier.getPhone().getNumber(),&#10;            courier.getPassword().getHashedValue(),&#10;            courier.getStatus().name(),&#10;            Timestamp.valueOf(courier.getCreatedAt())&#10;        );&#10;&#10;        return new Courier(&#10;            generatedId,&#10;            courier.getName(),&#10;            courier.getEmail(),&#10;            courier.getPhone(),&#10;            courier.getPassword(),&#10;            courier.getStatus(),&#10;            courier.getCreatedAt(),&#10;            courier.getLastLoginAt()&#10;        );&#10;    }&#10;&#10;    private Courier update(Courier courier) {&#10;        String sql = &quot;&quot;&quot;&#10;            UPDATE couriers &#10;            SET name = ?, phone = ?, status = ? &#10;            WHERE id = ?&#10;            &quot;&quot;&quot;;&#10;&#10;        jdbcTemplate.update(sql,&#10;            courier.getName(),&#10;            courier.getPhone().getNumber(),&#10;            courier.getStatus().name(),&#10;            courier.getId()&#10;        );&#10;&#10;        return courier;&#10;    }&#10;&#10;    @Override&#10;    public boolean existsByEmail(Email email) {&#10;        String sql = &quot;SELECT COUNT(*) FROM couriers WHERE email = ?&quot;;&#10;        Integer count = jdbcTemplate.queryForObject(sql, Integer.class, email.getValue());&#10;        return count != null &amp;&amp; count &gt; 0;&#10;    }&#10;&#10;    @Override&#10;    public void updateLastLogin(Long courierId) {&#10;        String sql = &quot;UPDATE couriers SET last_login_at = ? WHERE id = ?&quot;;&#10;        jdbcTemplate.update(sql, Timestamp.valueOf(LocalDateTime.now()), courierId);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.api.demo.infrastructure.adapter.output.persistence;&#10;&#10;import com.api.demo.domain.model.Courier;&#10;import com.api.demo.domain.model.CourierStatus;&#10;import com.api.demo.domain.port.output.CourierRepository;&#10;import com.api.demo.domain.valueobject.Email;&#10;import com.api.demo.domain.valueobject.Password;&#10;import com.api.demo.domain.valueobject.Phone;&#10;import org.springframework.jdbc.core.JdbcTemplate;&#10;import org.springframework.jdbc.core.RowMapper;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.sql.Timestamp;&#10;import java.time.LocalDateTime;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public class JdbcCourierRepository implements CourierRepository {&#10;&#10;    private final JdbcTemplate jdbcTemplate;&#10;&#10;    public JdbcCourierRepository(JdbcTemplate jdbcTemplate) {&#10;        this.jdbcTemplate = jdbcTemplate;&#10;    }&#10;&#10;    private final RowMapper&lt;Courier&gt; courierRowMapper = (rs, rowNum) -&gt; {&#10;        return new Courier(&#10;            rs.getLong(&quot;id&quot;),&#10;            rs.getString(&quot;name&quot;),&#10;            new Email(rs.getString(&quot;email&quot;)),&#10;            new Phone(rs.getString(&quot;phone&quot;)),&#10;            new Password(rs.getString(&quot;password_hash&quot;)),&#10;            CourierStatus.valueOf(rs.getString(&quot;status&quot;)),&#10;            rs.getTimestamp(&quot;created_at&quot;).toLocalDateTime(),&#10;            rs.getTimestamp(&quot;last_login_at&quot;) != null ?&#10;                rs.getTimestamp(&quot;last_login_at&quot;).toLocalDateTime() : null&#10;        );&#10;    };&#10;&#10;    @Override&#10;    public Optional&lt;Courier&gt; findById(Long id) {&#10;        String sql = &quot;&quot;&quot;&#10;            SELECT id, name, email, phone, password_hash, status, created_at, last_login_at &#10;            FROM couriers &#10;            WHERE id = ?&#10;            &quot;&quot;&quot;;&#10;&#10;        return jdbcTemplate.query(sql, courierRowMapper, id)&#10;                .stream()&#10;                .findFirst();&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;Courier&gt; findByEmail(Email email) {&#10;        String sql = &quot;&quot;&quot;&#10;            SELECT id, name, email, phone, password_hash, status, created_at, last_login_at &#10;            FROM couriers &#10;            WHERE email = ?&#10;            &quot;&quot;&quot;;&#10;&#10;        try {&#10;            return jdbcTemplate.query(sql, courierRowMapper, email.getValue())&#10;                    .stream()&#10;                    .findFirst();&#10;        } catch (Exception e) {&#10;            // Log the error and return empty&#10;            System.err.println(&quot;Error finding courier by email: &quot; + e.getMessage());&#10;            return Optional.empty();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Courier save(Courier courier) {&#10;        if (courier.getId() == null) {&#10;            return insert(courier);&#10;        } else {&#10;            return update(courier);&#10;        }&#10;    }&#10;&#10;    private Courier insert(Courier courier) {&#10;        String sql = &quot;&quot;&quot;&#10;            INSERT INTO couriers (name, email, phone, password_hash, status, created_at) &#10;            VALUES (?, ?, ?, ?, CAST(? AS user_status), ?)&#10;            RETURNING id&#10;            &quot;&quot;&quot;;&#10;&#10;        Long generatedId = jdbcTemplate.queryForObject(sql, Long.class,&#10;            courier.getName(),&#10;            courier.getEmail().getValue(),&#10;            courier.getPhone().getNumber(),&#10;            courier.getPassword().getHashedValue(),&#10;            courier.getStatus().name(),&#10;            Timestamp.valueOf(courier.getCreatedAt())&#10;        );&#10;&#10;        return new Courier(&#10;            generatedId,&#10;            courier.getName(),&#10;            courier.getEmail(),&#10;            courier.getPhone(),&#10;            courier.getPassword(),&#10;            courier.getStatus(),&#10;            courier.getCreatedAt(),&#10;            courier.getLastLoginAt()&#10;        );&#10;    }&#10;&#10;    private Courier update(Courier courier) {&#10;        String sql = &quot;&quot;&quot;&#10;            UPDATE couriers &#10;            SET name = ?, phone = ?, status = ? &#10;            WHERE id = ?&#10;            &quot;&quot;&quot;;&#10;&#10;        jdbcTemplate.update(sql,&#10;            courier.getName(),&#10;            courier.getPhone().getNumber(),&#10;            courier.getStatus().name(),&#10;            courier.getId()&#10;        );&#10;&#10;        return courier;&#10;    }&#10;&#10;    @Override&#10;    public boolean existsByEmail(Email email) {&#10;        String sql = &quot;SELECT COUNT(*) FROM couriers WHERE email = ?&quot;;&#10;        Integer count = jdbcTemplate.queryForObject(sql, Integer.class, email.getValue());&#10;        return count != null &amp;&amp; count &gt; 0;&#10;    }&#10;&#10;    @Override&#10;    public void updateLastLogin(Long courierId) {&#10;        String sql = &quot;UPDATE couriers SET last_login_at = ? WHERE id = ?&quot;;&#10;        jdbcTemplate.update(sql, Timestamp.valueOf(LocalDateTime.now()), courierId);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/api/demo/repository/OrderAssignmentRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/api/demo/repository/OrderAssignmentRepository.java" />
              <option name="originalContent" value="package com.api.demo.repository;&#10;&#10;import com.api.demo.model.OrderAssignment;&#10;import com.api.demo.model.enums.AssignmentStatus;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.time.OffsetDateTime;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public interface OrderAssignmentRepository extends JpaRepository&lt;OrderAssignment, Long&gt; {&#10;&#10;    List&lt;OrderAssignment&gt; findByOrderIdOrderByAssignedAtDesc(Long orderId);&#10;&#10;    List&lt;OrderAssignment&gt; findByCourierIdAndStatusOrderByAssignedAtDesc(Long courierId, AssignmentStatus status);&#10;&#10;    List&lt;OrderAssignment&gt; findByOrderIdAndStatusOrderByAssignedAtDesc(Long orderId, AssignmentStatus status);&#10;&#10;    Optional&lt;OrderAssignment&gt; findFirstByOrderIdAndStatusOrderByAssignedAtDesc(Long orderId, AssignmentStatus status);&#10;&#10;    @Query(&quot;SELECT a FROM OrderAssignment a WHERE a.status = 'PENDING' AND a.timeoutAt &lt;= :now&quot;)&#10;    List&lt;OrderAssignment&gt; findTimedOutAssignments(OffsetDateTime now);&#10;&#10;    List&lt;OrderAssignment&gt; findByStatusAndTimeoutAtBefore(AssignmentStatus status, OffsetDateTime now);&#10;&#10;    // Check if order already has a pending assignment (to prevent duplicates)&#10;    boolean existsByOrderIdAndStatus(Long orderId, AssignmentStatus status);&#10;    &#10;    // Find active (pending) assignment for an order&#10;    Optional&lt;OrderAssignment&gt; findByOrderIdAndStatus(Long orderId, AssignmentStatus status);&#10;    &#10;    // Find valid (non-expired) pending assignments for a courier&#10;    @Query(&quot;SELECT a FROM OrderAssignment a WHERE a.courierId = :courierId &quot; +&#10;           &quot;AND a.status = 'PENDING' &quot; +&#10;           &quot;AND (a.timeoutAt IS NULL OR a.timeoutAt &gt; CURRENT_TIMESTAMP) &quot; +&#10;           &quot;ORDER BY a.assignedAt DESC&quot;)&#10;    List&lt;OrderAssignment&gt; findValidPendingAssignmentsByCourierId(@Param(&quot;courierId&quot;) Long courierId);&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.api.demo.repository;&#10;&#10;import com.api.demo.model.OrderAssignment;&#10;import com.api.demo.model.enums.AssignmentStatus;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.time.OffsetDateTime;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public interface OrderAssignmentRepository extends JpaRepository&lt;OrderAssignment, Long&gt; {&#10;&#10;    List&lt;OrderAssignment&gt; findByOrderIdOrderByAssignedAtDesc(Long orderId);&#10;&#10;    List&lt;OrderAssignment&gt; findByCourierIdAndStatusOrderByAssignedAtDesc(Long courierId, AssignmentStatus status);&#10;&#10;    List&lt;OrderAssignment&gt; findByOrderIdAndStatusOrderByAssignedAtDesc(Long orderId, AssignmentStatus status);&#10;&#10;    Optional&lt;OrderAssignment&gt; findFirstByOrderIdAndStatusOrderByAssignedAtDesc(Long orderId, AssignmentStatus status);&#10;&#10;    @Query(&quot;SELECT a FROM OrderAssignment a WHERE a.status = 'PENDING' AND a.timeoutAt &lt;= :now&quot;)&#10;    List&lt;OrderAssignment&gt; findTimedOutAssignments(OffsetDateTime now);&#10;&#10;    List&lt;OrderAssignment&gt; findByStatusAndTimeoutAtBefore(AssignmentStatus status, OffsetDateTime now);&#10;&#10;    // Check if order already has a pending assignment (to prevent duplicates)&#10;    boolean existsByOrderIdAndStatus(Long orderId, AssignmentStatus status);&#10;    &#10;    // Find active (pending) assignment for an order&#10;    Optional&lt;OrderAssignment&gt; findByOrderIdAndStatus(Long orderId, AssignmentStatus status);&#10;    &#10;    // Find valid (non-expired) pending assignments for a courier&#10;    @Query(&quot;SELECT a FROM OrderAssignment a WHERE a.courierId = :courierId &quot; +&#10;           &quot;AND a.status = 'PENDING' &quot; +&#10;           &quot;AND (a.timeoutAt IS NULL OR a.timeoutAt &gt; CURRENT_TIMESTAMP) &quot; +&#10;           &quot;ORDER BY a.assignedAt DESC&quot;)&#10;    List&lt;OrderAssignment&gt; findValidPendingAssignmentsByCourierId(@Param(&quot;courierId&quot;) Long courierId);&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/api/demo/service/ShiftService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/api/demo/service/ShiftService.java" />
              <option name="originalContent" value="package com.api.demo.service;&#10;&#10;import com.api.demo.dto.*;&#10;import com.api.demo.exception.BusinessException;&#10;import com.api.demo.model.Courier;&#10;import com.api.demo.model.Shift;&#10;import com.api.demo.model.ShiftTemplate;&#10;import com.api.demo.model.enums.ShiftStatus;&#10;import com.api.demo.repository.CourierRepository;&#10;import com.api.demo.repository.ShiftRepository;&#10;import com.api.demo.repository.ShiftTemplateRepository;&#10;import com.api.demo.service.OnDutyService;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Vardiya yönetim servisi&#10; * Kuryelerin vardiya rezervasyonu, check-in/out işlemlerini yönetir&#10; */&#10;@Service&#10;public class ShiftService {&#10;&#10;    private final ShiftRepository shiftRepository;&#10;    private final ShiftTemplateRepository shiftTemplateRepository;&#10;    private final CourierRepository courierRepository;&#10;    private final OnDutyService onDutyService;&#10;&#10;    public ShiftService(ShiftRepository shiftRepository,&#10;                       ShiftTemplateRepository shiftTemplateRepository,&#10;                       CourierRepository courierRepository,&#10;                       OnDutyService onDutyService) {&#10;        this.shiftRepository = shiftRepository;&#10;        this.shiftTemplateRepository = shiftTemplateRepository;&#10;        this.courierRepository = courierRepository;&#10;        this.onDutyService = onDutyService;&#10;    }&#10;&#10;    /**&#10;     * Mevcut tüm vardiya şablonlarını listele&#10;     */&#10;    public List&lt;ShiftTemplateDTO&gt; getAvailableShiftTemplates() {&#10;        return shiftTemplateRepository.findByIsActiveTrueOrderByStartTimeAsc()&#10;                .stream()&#10;                .map(this::convertToTemplateDTO)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Kurye için vardiya rezerve et&#10;     */&#10;    @Transactional&#10;    public ShiftDTO reserveShift(Long courierId, ReserveShiftRequest request) {&#10;        // Kurye kontrolü&#10;        Courier courier = courierRepository.findById(courierId)&#10;                .orElseThrow(() -&gt; new BusinessException(&quot;Kurye bulunamadı&quot;));&#10;&#10;        // Şablon kontrolü&#10;        ShiftTemplate template = shiftTemplateRepository.findById(request.getTemplateId())&#10;                .orElseThrow(() -&gt; new BusinessException(&quot;Vardiya şablonu bulunamadı&quot;));&#10;&#10;        if (!template.getIsActive()) {&#10;            throw new BusinessException(&quot;Bu vardiya şablonu aktif değil&quot;);&#10;        }&#10;&#10;        // Tarih kontrolü - geçmiş tarih olamaz&#10;        if (request.getShiftDate().isBefore(LocalDate.now())) {&#10;            throw new BusinessException(&quot;Geçmiş tarihli vardiya rezerve edilemez&quot;);&#10;        }&#10;&#10;        // Başlangıç ve bitiş zamanlarını hesapla&#10;        LocalDateTime startTime = LocalDateTime.of(request.getShiftDate(), template.getStartTime());&#10;        LocalDateTime endTime = LocalDateTime.of(request.getShiftDate(), template.getEndTime());&#10;&#10;        // Eğer bitiş zamanı başlangıçtan önce ise (gece vardiyası), bir gün ekle&#10;        if (template.getEndTime().isBefore(template.getStartTime())) {&#10;            endTime = endTime.plusDays(1);&#10;        }&#10;&#10;        // Zaman çakışması kontrolü&#10;        if (shiftRepository.hasOverlappingShift(courierId, startTime, endTime)) {&#10;            throw new BusinessException(&quot;Bu zaman aralığında zaten bir vardiya rezervasyonunuz var&quot;);&#10;        }&#10;&#10;        // Yeni vardiya oluştur&#10;        Shift shift = new Shift();&#10;        shift.setCourierId(courierId);&#10;        shift.setStartTime(startTime);&#10;        shift.setEndTime(endTime);&#10;        shift.setShiftRole(template.getDefaultRole());&#10;        shift.setStatus(ShiftStatus.RESERVED);&#10;        shift.setNotes(request.getNotes());&#10;&#10;        Shift savedShift = shiftRepository.save(shift);&#10;&#10;        ShiftDTO dto = convertToDTO(savedShift);&#10;        dto.setCourierName(courier.getName());&#10;        return dto;&#10;    }&#10;&#10;    /**&#10;     * Kuryenin gelecek vardiyalarını listele&#10;     */&#10;    public List&lt;ShiftDTO&gt; getUpcomingShifts(Long courierId) {&#10;        List&lt;Shift&gt; shifts = shiftRepository.findUpcomingReservedShifts(courierId, LocalDateTime.now());&#10;        return shifts.stream()&#10;                .map(this::convertToDTO)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Kuryenin tüm vardiyalarını listele (filtre ile)&#10;     */&#10;    public List&lt;ShiftDTO&gt; getCourierShifts(Long courierId, ShiftStatus status) {&#10;        List&lt;Shift&gt; shifts;&#10;        if (status != null) {&#10;            shifts = shiftRepository.findByCourierIdAndStatusOrderByStartTimeDesc(courierId, status);&#10;        } else {&#10;            shifts = shiftRepository.findByCourierIdAndStartTimeBetween(&#10;                    courierId,&#10;                    LocalDateTime.now().minusMonths(3),&#10;                    LocalDateTime.now().plusMonths(3)&#10;            );&#10;        }&#10;        return shifts.stream()&#10;                .map(this::convertToDTO)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Vardiyaya check-in yap&#10;     */&#10;    @Transactional&#10;    public ShiftDTO checkIn(Long courierId, Long shiftId, CheckInRequest request) {&#10;        // Vardiya kontrolü&#10;        Shift shift = shiftRepository.findById(shiftId)&#10;                .orElseThrow(() -&gt; new BusinessException(&quot;Vardiya bulunamadı&quot;));&#10;&#10;        // Kurye kontrolü&#10;        if (!shift.getCourierId().equals(courierId)) {&#10;            throw new BusinessException(&quot;Bu vardiya size ait değil&quot;);&#10;        }&#10;&#10;        // Durum kontrolü&#10;        if (shift.getStatus() != ShiftStatus.RESERVED) {&#10;            throw new BusinessException(&quot;Bu vardiyaya zaten giriş yapılmış veya iptal edilmiş&quot;);&#10;        }&#10;&#10;        // Zaman kontrolü - 30 dakika önceden check-in yapılabilir&#10;        LocalDateTime now = LocalDateTime.now();&#10;        LocalDateTime earliestCheckIn = shift.getStartTime().minusMinutes(30);&#10;&#10;        if (now.isBefore(earliestCheckIn)) {&#10;            throw new BusinessException(&quot;Vardiyaya giriş için henüz erken. En erken giriş zamanı: &quot; + earliestCheckIn);&#10;        }&#10;&#10;        // Check-in işlemi&#10;        shift.setStatus(ShiftStatus.CHECKED_IN);&#10;        shift.setCheckInTime(now);&#10;        if (request.getNotes() != null) {&#10;            shift.setNotes(shift.getNotes() + &quot;\nCheck-in: &quot; + request.getNotes());&#10;        }&#10;&#10;        Shift savedShift = shiftRepository.save(shift);&#10;&#10;        // Courier'ın on_duty bilgisini onDutyService üzerinden yönet&#10;        onDutyService.upsertOnDuty(courierId, shiftId);&#10;&#10;        // Ayrıca courier status'ünü güncelle&#10;        Courier courier = courierRepository.findById(courierId)&#10;                .orElseThrow(() -&gt; new BusinessException(&quot;Kurye bulunamadı&quot;));&#10;        courier.setOnDutySince(now);&#10;        courier.setStatus(Courier.CourierStatus.ONLINE);&#10;        courierRepository.save(courier);&#10;&#10;        ShiftDTO dto = convertToDTO(savedShift);&#10;        dto.setCourierName(courier.getName());&#10;        return dto;&#10;    }&#10;&#10;    /**&#10;     * Vardiyadan check-out yap&#10;     */&#10;    @Transactional&#10;    public ShiftDTO checkOut(Long courierId, Long shiftId, CheckOutRequest request) {&#10;        // Vardiya kontrolü&#10;        Shift shift = shiftRepository.findById(shiftId)&#10;                .orElseThrow(() -&gt; new BusinessException(&quot;Vardiya bulunamadı&quot;));&#10;&#10;        // Kurye kontrolü&#10;        if (!shift.getCourierId().equals(courierId)) {&#10;            throw new BusinessException(&quot;Bu vardiya size ait değil&quot;);&#10;        }&#10;&#10;        // Durum kontrolü&#10;        if (shift.getStatus() != ShiftStatus.CHECKED_IN) {&#10;            throw new BusinessException(&quot;Bu vardiyaya giriş yapılmamış&quot;);&#10;        }&#10;&#10;        // Check-out işlemi&#10;        LocalDateTime now = LocalDateTime.now();&#10;        shift.setStatus(ShiftStatus.CHECKED_OUT);&#10;        shift.setCheckOutTime(now);&#10;        if (request.getNotes() != null) {&#10;            shift.setNotes(shift.getNotes() + &quot;\nCheck-out: &quot; + request.getNotes());&#10;        }&#10;&#10;        Shift savedShift = shiftRepository.save(shift);&#10;&#10;        // Courier'ın on_duty bilgisini kaldır (on_duty_couriers tablosundan sil)&#10;        onDutyService.removeOnDuty(courierId);&#10;&#10;        // Courier'ın on_duty_since alanını temizle&#10;        Courier courier = courierRepository.findById(courierId)&#10;                .orElseThrow(() -&gt; new BusinessException(&quot;Kurye bulunamadı&quot;));&#10;        courier.setOnDutySince(null);&#10;        courier.setStatus(Courier.CourierStatus.OFFLINE);&#10;        courierRepository.save(courier);&#10;&#10;        ShiftDTO dto = convertToDTO(savedShift);&#10;        dto.setCourierName(courier.getName());&#10;        return dto;&#10;    }&#10;&#10;    /**&#10;     * Vardiya rezervasyonunu iptal et&#10;     */&#10;    @Transactional&#10;    public void cancelShift(Long courierId, Long shiftId) {&#10;        Shift shift = shiftRepository.findById(shiftId)&#10;                .orElseThrow(() -&gt; new BusinessException(&quot;Vardiya bulunamadı&quot;));&#10;&#10;        if (!shift.getCourierId().equals(courierId)) {&#10;            throw new BusinessException(&quot;Bu vardiya size ait değil&quot;);&#10;        }&#10;&#10;        if (shift.getStatus() != ShiftStatus.RESERVED) {&#10;            throw new BusinessException(&quot;Sadece rezerve edilmiş vardiyalar iptal edilebilir&quot;);&#10;        }&#10;&#10;        // İptal işlemi - vardiya başlamadan en az 2 saat önce iptal edilebilir&#10;        if (shift.getStartTime().minusHours(2).isBefore(LocalDateTime.now())) {&#10;            throw new BusinessException(&quot;Vardiya başlangıcına 2 saatten az kaldı, iptal edilemez&quot;);&#10;        }&#10;&#10;        shift.setStatus(ShiftStatus.CANCELLED);&#10;        shiftRepository.save(shift);&#10;    }&#10;&#10;    /**&#10;     * Kuryenin aktif (CHECKED_IN) vardiyasını getir&#10;     */&#10;    public ShiftDTO getActiveShift(Long courierId) {&#10;        return shiftRepository.findByCourierIdAndStatus(courierId, ShiftStatus.CHECKED_IN)&#10;                .map(this::convertToDTO)&#10;                .orElse(null);&#10;    }&#10;&#10;    // DTO Dönüşüm metodları&#10;    private ShiftDTO convertToDTO(Shift shift) {&#10;        ShiftDTO dto = new ShiftDTO();&#10;        dto.setShiftId(shift.getShiftId());&#10;        dto.setCourierId(shift.getCourierId());&#10;        dto.setStartTime(shift.getStartTime());&#10;        dto.setEndTime(shift.getEndTime());&#10;        dto.setShiftRole(shift.getShiftRole());&#10;        dto.setStatus(shift.getStatus());&#10;        dto.setCheckInTime(shift.getCheckInTime());&#10;        dto.setCheckOutTime(shift.getCheckOutTime());&#10;        dto.setNotes(shift.getNotes());&#10;        dto.setCreatedAt(shift.getCreatedAt());&#10;        return dto;&#10;    }&#10;&#10;    private ShiftTemplateDTO convertToTemplateDTO(ShiftTemplate template) {&#10;        ShiftTemplateDTO dto = new ShiftTemplateDTO();&#10;        dto.setTemplateId(template.getTemplateId());&#10;        dto.setName(template.getName());&#10;        dto.setDescription(template.getDescription());&#10;        dto.setStartTime(template.getStartTime());&#10;        dto.setEndTime(template.getEndTime());&#10;        dto.setDefaultRole(template.getDefaultRole());&#10;        dto.setMaxCouriers(template.getMaxCouriers());&#10;        dto.setIsActive(template.getIsActive());&#10;        return dto;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.api.demo.service;&#10;&#10;import com.api.demo.dto.*;&#10;import com.api.demo.exception.BusinessException;&#10;import com.api.demo.model.Courier;&#10;import com.api.demo.model.Shift;&#10;import com.api.demo.model.ShiftTemplate;&#10;import com.api.demo.model.enums.ShiftStatus;&#10;import com.api.demo.repository.CourierRepository;&#10;import com.api.demo.repository.ShiftRepository;&#10;import com.api.demo.repository.ShiftTemplateRepository;&#10;import com.api.demo.service.OnDutyService;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Vardiya yönetim servisi&#10; * Kuryelerin vardiya rezervasyonu, check-in/out işlemlerini yönetir&#10; */&#10;@Service&#10;public class ShiftService {&#10;&#10;    private final ShiftRepository shiftRepository;&#10;    private final ShiftTemplateRepository shiftTemplateRepository;&#10;    private final CourierRepository courierRepository;&#10;    private final OnDutyService onDutyService;&#10;&#10;    public ShiftService(ShiftRepository shiftRepository,&#10;                       ShiftTemplateRepository shiftTemplateRepository,&#10;                       CourierRepository courierRepository,&#10;                       OnDutyService onDutyService) {&#10;        this.shiftRepository = shiftRepository;&#10;        this.shiftTemplateRepository = shiftTemplateRepository;&#10;        this.courierRepository = courierRepository;&#10;        this.onDutyService = onDutyService;&#10;    }&#10;&#10;    /**&#10;     * Mevcut tüm vardiya şablonlarını listele&#10;     */&#10;    public List&lt;ShiftTemplateDTO&gt; getAvailableShiftTemplates() {&#10;        return shiftTemplateRepository.findByIsActiveTrueOrderByStartTimeAsc()&#10;                .stream()&#10;                .map(this::convertToTemplateDTO)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Kurye için vardiya rezerve et&#10;     */&#10;    @Transactional&#10;    public ShiftDTO reserveShift(Long courierId, ReserveShiftRequest request) {&#10;        // Kurye kontrolü&#10;        Courier courier = courierRepository.findById(courierId)&#10;                .orElseThrow(() -&gt; new BusinessException(&quot;Kurye bulunamadı&quot;));&#10;&#10;        // Şablon kontrolü&#10;        ShiftTemplate template = shiftTemplateRepository.findById(request.getTemplateId())&#10;                .orElseThrow(() -&gt; new BusinessException(&quot;Vardiya şablonu bulunamadı&quot;));&#10;&#10;        if (!template.getIsActive()) {&#10;            throw new BusinessException(&quot;Bu vardiya şablonu aktif değil&quot;);&#10;        }&#10;&#10;        // Tarih kontrolü - geçmiş tarih olamaz&#10;        if (request.getShiftDate().isBefore(LocalDate.now())) {&#10;            throw new BusinessException(&quot;Geçmiş tarihli vardiya rezerve edilemez&quot;);&#10;        }&#10;&#10;        // Başlangıç ve bitiş zamanlarını hesapla&#10;        LocalDateTime startTime = LocalDateTime.of(request.getShiftDate(), template.getStartTime());&#10;        LocalDateTime endTime = LocalDateTime.of(request.getShiftDate(), template.getEndTime());&#10;&#10;        // Eğer bitiş zamanı başlangıçtan önce ise (gece vardiyası), bir gün ekle&#10;        if (template.getEndTime().isBefore(template.getStartTime())) {&#10;            endTime = endTime.plusDays(1);&#10;        }&#10;&#10;        // Zaman çakışması kontrolü&#10;        if (shiftRepository.hasOverlappingShift(courierId, startTime, endTime)) {&#10;            throw new BusinessException(&quot;Bu zaman aralığında zaten bir vardiya rezervasyonunuz var&quot;);&#10;        }&#10;&#10;        // Yeni vardiya oluştur&#10;        Shift shift = new Shift();&#10;        shift.setCourierId(courierId);&#10;        shift.setStartTime(startTime);&#10;        shift.setEndTime(endTime);&#10;        shift.setShiftRole(template.getDefaultRole());&#10;        shift.setStatus(ShiftStatus.RESERVED);&#10;        shift.setNotes(request.getNotes());&#10;&#10;        Shift savedShift = shiftRepository.save(shift);&#10;&#10;        ShiftDTO dto = convertToDTO(savedShift);&#10;        dto.setCourierName(courier.getName());&#10;        return dto;&#10;    }&#10;&#10;    /**&#10;     * Kuryenin gelecek vardiyalarını listele&#10;     */&#10;    public List&lt;ShiftDTO&gt; getUpcomingShifts(Long courierId) {&#10;        List&lt;Shift&gt; shifts = shiftRepository.findUpcomingReservedShifts(courierId, LocalDateTime.now());&#10;        return shifts.stream()&#10;                .map(this::convertToDTO)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Kuryenin tüm vardiyalarını listele (filtre ile)&#10;     */&#10;    public List&lt;ShiftDTO&gt; getCourierShifts(Long courierId, ShiftStatus status) {&#10;        List&lt;Shift&gt; shifts;&#10;        if (status != null) {&#10;            shifts = shiftRepository.findByCourierIdAndStatusOrderByStartTimeDesc(courierId, status);&#10;        } else {&#10;            shifts = shiftRepository.findByCourierIdAndStartTimeBetween(&#10;                    courierId,&#10;                    LocalDateTime.now().minusMonths(3),&#10;                    LocalDateTime.now().plusMonths(3)&#10;            );&#10;        }&#10;        return shifts.stream()&#10;                .map(this::convertToDTO)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Vardiyaya check-in yap&#10;     */&#10;    @Transactional&#10;    public ShiftDTO checkIn(Long courierId, Long shiftId, CheckInRequest request) {&#10;        // Vardiya kontrolü&#10;        Shift shift = shiftRepository.findById(shiftId)&#10;                .orElseThrow(() -&gt; new BusinessException(&quot;Vardiya bulunamadı&quot;));&#10;&#10;        // Kurye kontrolü&#10;        if (!shift.getCourierId().equals(courierId)) {&#10;            throw new BusinessException(&quot;Bu vardiya size ait değil&quot;);&#10;        }&#10;&#10;        // Durum kontrolü&#10;        if (shift.getStatus() != ShiftStatus.RESERVED) {&#10;            throw new BusinessException(&quot;Bu vardiyaya zaten giriş yapılmış veya iptal edilmiş&quot;);&#10;        }&#10;&#10;        // Zaman kontrolü - 30 dakika önceden check-in yapılabilir&#10;        LocalDateTime now = LocalDateTime.now();&#10;        LocalDateTime earliestCheckIn = shift.getStartTime().minusMinutes(30);&#10;&#10;        if (now.isBefore(earliestCheckIn)) {&#10;            throw new BusinessException(&quot;Vardiyaya giriş için henüz erken. En erken giriş zamanı: &quot; + earliestCheckIn);&#10;        }&#10;&#10;        // Check-in işlemi&#10;        shift.setStatus(ShiftStatus.CHECKED_IN);&#10;        shift.setCheckInTime(now);&#10;        if (request.getNotes() != null) {&#10;            shift.setNotes(shift.getNotes() + &quot;\nCheck-in: &quot; + request.getNotes());&#10;        }&#10;&#10;        Shift savedShift = shiftRepository.save(shift);&#10;&#10;        // Courier'ın on_duty bilgisini onDutyService üzerinden yönet&#10;        onDutyService.upsertOnDuty(courierId, shiftId);&#10;&#10;        // Ayrıca courier status'ünü güncelle&#10;        Courier courier = courierRepository.findById(courierId)&#10;                .orElseThrow(() -&gt; new BusinessException(&quot;Kurye bulunamadı&quot;));&#10;        courier.setOnDutySince(now);&#10;        courier.setStatus(Courier.CourierStatus.ONLINE);&#10;        courierRepository.save(courier);&#10;&#10;        ShiftDTO dto = convertToDTO(savedShift);&#10;        dto.setCourierName(courier.getName());&#10;        return dto;&#10;    }&#10;&#10;    /**&#10;     * Vardiyadan check-out yap&#10;     */&#10;    @Transactional&#10;    public ShiftDTO checkOut(Long courierId, Long shiftId, CheckOutRequest request) {&#10;        // Vardiya kontrolü&#10;        Shift shift = shiftRepository.findById(shiftId)&#10;                .orElseThrow(() -&gt; new BusinessException(&quot;Vardiya bulunamadı&quot;));&#10;&#10;        // Kurye kontrolü&#10;        if (!shift.getCourierId().equals(courierId)) {&#10;            throw new BusinessException(&quot;Bu vardiya size ait değil&quot;);&#10;        }&#10;&#10;        // Durum kontrolü&#10;        if (shift.getStatus() != ShiftStatus.CHECKED_IN) {&#10;            throw new BusinessException(&quot;Bu vardiyaya giriş yapılmamış&quot;);&#10;        }&#10;&#10;        // Check-out işlemi&#10;        LocalDateTime now = LocalDateTime.now();&#10;        shift.setStatus(ShiftStatus.CHECKED_OUT);&#10;        shift.setCheckOutTime(now);&#10;        if (request.getNotes() != null) {&#10;            shift.setNotes(shift.getNotes() + &quot;\nCheck-out: &quot; + request.getNotes());&#10;        }&#10;&#10;        Shift savedShift = shiftRepository.save(shift);&#10;&#10;        // Courier'ın on_duty bilgisini kaldır (on_duty_couriers tablosundan sil)&#10;        onDutyService.removeOnDuty(courierId);&#10;&#10;        // Courier'ın on_duty_since alanını temizle&#10;        Courier courier = courierRepository.findById(courierId)&#10;                .orElseThrow(() -&gt; new BusinessException(&quot;Kurye bulunamadı&quot;));&#10;        courier.setOnDutySince(null);&#10;        courier.setStatus(Courier.CourierStatus.OFFLINE);&#10;        courierRepository.save(courier);&#10;&#10;        ShiftDTO dto = convertToDTO(savedShift);&#10;        dto.setCourierName(courier.getName());&#10;        return dto;&#10;    }&#10;&#10;    /**&#10;     * Vardiya rezervasyonunu iptal et&#10;     */&#10;    @Transactional&#10;    public void cancelShift(Long courierId, Long shiftId) {&#10;        Shift shift = shiftRepository.findById(shiftId)&#10;                .orElseThrow(() -&gt; new BusinessException(&quot;Vardiya bulunamadı&quot;));&#10;&#10;        if (!shift.getCourierId().equals(courierId)) {&#10;            throw new BusinessException(&quot;Bu vardiya size ait değil&quot;);&#10;        }&#10;&#10;        if (shift.getStatus() != ShiftStatus.RESERVED) {&#10;            throw new BusinessException(&quot;Sadece rezerve edilmiş vardiyalar iptal edilebilir&quot;);&#10;        }&#10;&#10;        // İptal işlemi - vardiya başlamadan en az 2 saat önce iptal edilebilir&#10;        if (shift.getStartTime().minusHours(2).isBefore(LocalDateTime.now())) {&#10;            throw new BusinessException(&quot;Vardiya başlangıcına 2 saatten az kaldı, iptal edilemez&quot;);&#10;        }&#10;&#10;        shift.setStatus(ShiftStatus.CANCELLED);&#10;        shiftRepository.save(shift);&#10;    }&#10;&#10;    /**&#10;     * Kuryenin aktif (CHECKED_IN) vardiyasını getir&#10;     */&#10;    public ShiftDTO getActiveShift(Long courierId) {&#10;        return shiftRepository.findByCourierIdAndStatus(courierId, ShiftStatus.CHECKED_IN)&#10;                .map(this::convertToDTO)&#10;                .orElse(null);&#10;    }&#10;&#10;    // DTO Dönüşüm metodları&#10;    private ShiftDTO convertToDTO(Shift shift) {&#10;        ShiftDTO dto = new ShiftDTO();&#10;        dto.setShiftId(shift.getShiftId());&#10;        dto.setCourierId(shift.getCourierId());&#10;        dto.setStartTime(shift.getStartTime());&#10;        dto.setEndTime(shift.getEndTime());&#10;        dto.setShiftRole(shift.getShiftRole());&#10;        dto.setStatus(shift.getStatus());&#10;        dto.setCheckInTime(shift.getCheckInTime());&#10;        dto.setCheckOutTime(shift.getCheckOutTime());&#10;        dto.setNotes(shift.getNotes());&#10;        dto.setCreatedAt(shift.getCreatedAt());&#10;        return dto;&#10;    }&#10;&#10;    private ShiftTemplateDTO convertToTemplateDTO(ShiftTemplate template) {&#10;        ShiftTemplateDTO dto = new ShiftTemplateDTO();&#10;        dto.setTemplateId(template.getTemplateId());&#10;        dto.setName(template.getName());&#10;        dto.setDescription(template.getDescription());&#10;        dto.setStartTime(template.getStartTime());&#10;        dto.setEndTime(template.getEndTime());&#10;        dto.setDefaultRole(template.getDefaultRole());&#10;        dto.setMaxCouriers(template.getMaxCouriers());&#10;        dto.setIsActive(template.getIsActive());&#10;        return dto;&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>