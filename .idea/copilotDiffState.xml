<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/compose.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/compose.yaml" />
              <option name="originalContent" value="version: '3.8'&#10;&#10;services:&#10;  # PostgreSQL with PostGIS&#10;  postgres:&#10;    image: postgis/postgis:15-3.3&#10;    container_name: courier-postgres&#10;    environment:&#10;      POSTGRES_DB: courier_db&#10;      POSTGRES_USER: courier_user&#10;      POSTGRES_PASSWORD: courier_password&#10;    ports:&#10;      - &quot;5433:5432&quot;  # Yerel çakışmaları önlemek için 5433 kullanıyoruz&#10;    volumes:&#10;      - postgres_data:/var/lib/postgresql/data&#10;      # Migration scriptlerini devre dışı bırakıyoruz (yeni proje için Flyway tercih edilecek)&#10;    healthcheck:&#10;      test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U courier_user -d courier_db&quot;]&#10;      interval: 10s&#10;      timeout: 5s&#10;      retries: 5&#10;    networks:&#10;      - courier-network&#10;&#10;  # Redis Cache&#10;  redis:&#10;    image: redis:7-alpine&#10;    container_name: courier-redis&#10;    ports:&#10;      - &quot;6380:6379&quot;  # Yerel Redis çakışmalarını önlüyoruz&#10;    volumes:&#10;      - redis_data:/data&#10;    healthcheck:&#10;      test: [&quot;CMD&quot;, &quot;redis-cli&quot;, &quot;ping&quot;]&#10;      interval: 30s&#10;      timeout: 10s&#10;      retries: 3&#10;    networks:&#10;      - courier-network&#10;&#10;  # Zookeeper&#10;  zookeeper:&#10;    image: confluentinc/cp-zookeeper:latest&#10;    container_name: courier-zookeeper&#10;    environment:&#10;      ZOOKEEPER_CLIENT_PORT: 2181&#10;      ZOOKEEPER_TICK_TIME: 2000&#10;    ports:&#10;      - &quot;2182:2181&quot;  # Yerel çakışmaları önleme&#10;    networks:&#10;      - courier-network&#10;&#10;  # Kafka - düzeltilmiş yapılandırma&#10;  kafka:&#10;    image: confluentinc/cp-kafka:latest&#10;    container_name: courier-kafka&#10;    depends_on:&#10;      - zookeeper&#10;    environment:&#10;      KAFKA_BROKER_ID: 1&#10;      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181&#10;      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT&#10;      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092,PLAINTEXT_HOST://localhost:29092&#10;      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092,PLAINTEXT_HOST://0.0.0.0:29092&#10;      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1&#10;      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1&#10;      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1&#10;      # Gerekli Kafka parametreleri&#10;      KAFKA_PROCESS_ROLES: broker&#10;      KAFKA_NODE_ID: 1&#10;    ports:&#10;      - &quot;29092:29092&quot;  # Dış erişim için port&#10;      - &quot;9093:9092&quot;    # Yerel çakışmaları önlemek için değiştirildi&#10;    networks:&#10;      - courier-network&#10;&#10;  # Spring Boot Backend&#10;  backend:&#10;    build: .&#10;    container_name: courier-backend&#10;    depends_on:&#10;      postgres:&#10;        condition: service_healthy&#10;      redis:&#10;        condition: service_healthy&#10;      kafka:&#10;        condition: service_started&#10;    environment:&#10;      SPRING_PROFILES_ACTIVE: docker&#10;      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/courier_db&#10;      SPRING_DATASOURCE_USERNAME: courier_user&#10;      SPRING_DATASOURCE_PASSWORD: courier_password&#10;      SPRING_DATA_REDIS_HOST: redis&#10;      SPRING_DATA_REDIS_PORT: 6379&#10;      SPRING_KAFKA_BOOTSTRAP_SERVERS: kafka:9092&#10;      # Enable Flyway to create database tables&#10;      SPRING_FLYWAY_ENABLED: &quot;true&quot;&#10;    ports:&#10;      - &quot;8081:8080&quot;&#10;    networks:&#10;      - courier-network&#10;&#10;volumes:&#10;  postgres_data:&#10;  redis_data:&#10;&#10;networks:&#10;  courier-network:&#10;    driver: bridge&#10;" />
              <option name="updatedContent" value="version: '3.8'&#10;&#10;services:&#10;  # PostgreSQL with PostGIS&#10;  postgres:&#10;    image: postgis/postgis:15-3.3&#10;    container_name: courier-postgres&#10;    environment:&#10;      POSTGRES_DB: courier_db&#10;      POSTGRES_USER: courier_user&#10;      POSTGRES_PASSWORD: courier_password&#10;    ports:&#10;      - &quot;5433:5432&quot;  # Yerel çakışmaları önlemek için 5433 kullanıyoruz&#10;    volumes:&#10;      - postgres_data:/var/lib/postgresql/data&#10;      # Migration scriptlerini devre dışı bırakıyoruz (yeni proje için Flyway tercih edilecek)&#10;    healthcheck:&#10;      test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U courier_user -d courier_db&quot;]&#10;      interval: 10s&#10;      timeout: 5s&#10;      retries: 5&#10;    networks:&#10;      - courier-network&#10;&#10;  # Redis Cache&#10;  redis:&#10;    image: redis:7-alpine&#10;    container_name: courier-redis&#10;    ports:&#10;      - &quot;6380:6379&quot;  # Yerel Redis çakışmalarını önlüyoruz&#10;    volumes:&#10;      - redis_data:/data&#10;    healthcheck:&#10;      test: [&quot;CMD&quot;, &quot;redis-cli&quot;, &quot;ping&quot;]&#10;      interval: 30s&#10;      timeout: 10s&#10;      retries: 3&#10;    networks:&#10;      - courier-network&#10;&#10;  # Zookeeper&#10;  zookeeper:&#10;    image: confluentinc/cp-zookeeper:latest&#10;    container_name: courier-zookeeper&#10;    environment:&#10;      ZOOKEEPER_CLIENT_PORT: 2181&#10;      ZOOKEEPER_TICK_TIME: 2000&#10;    ports:&#10;      - &quot;2182:2181&quot;  # Yerel çakışmaları önleme&#10;    networks:&#10;      - courier-network&#10;&#10;  # Kafka - düzeltilmiş yapılandırma&#10;  kafka:&#10;    image: confluentinc/cp-kafka:latest&#10;    container_name: courier-kafka&#10;    depends_on:&#10;      - zookeeper&#10;    environment:&#10;      KAFKA_BROKER_ID: 1&#10;      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181&#10;      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT&#10;      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092,PLAINTEXT_HOST://localhost:29092&#10;      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092,PLAINTEXT_HOST://0.0.0.0:29092&#10;      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1&#10;      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1&#10;      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1&#10;      # Gerekli Kafka parametreleri&#10;      KAFKA_PROCESS_ROLES: broker&#10;      KAFKA_NODE_ID: 1&#10;    ports:&#10;      - &quot;29092:29092&quot;  # Dış erişim için port&#10;      - &quot;9093:9092&quot;    # Yerel çakışmaları önlemek için değiştirildi&#10;    networks:&#10;      - courier-network&#10;&#10;  # Spring Boot Backend&#10;  backend:&#10;    build: .&#10;    container_name: courier-backend&#10;    depends_on:&#10;      postgres:&#10;        condition: service_healthy&#10;      redis:&#10;        condition: service_healthy&#10;      kafka:&#10;        condition: service_started&#10;    environment:&#10;      SPRING_PROFILES_ACTIVE: docker&#10;      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/courier_db&#10;      SPRING_DATASOURCE_USERNAME: courier_user&#10;      SPRING_DATASOURCE_PASSWORD: courier_password&#10;      SPRING_DATA_REDIS_HOST: redis&#10;      SPRING_DATA_REDIS_PORT: 6379&#10;      SPRING_KAFKA_BOOTSTRAP_SERVERS: kafka:9092&#10;      # Enable Flyway to create database tables&#10;      SPRING_FLYWAY_ENABLED: &quot;true&quot;&#10;    ports:&#10;      - &quot;8081:8080&quot;&#10;    networks:&#10;      - courier-network&#10;&#10;volumes:&#10;  postgres_data:&#10;  redis_data:&#10;&#10;networks:&#10;  courier-network:&#10;    driver: bridge" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/api/demo/infrastructure/adapter/output/persistence/JdbcCourierRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/api/demo/infrastructure/adapter/output/persistence/JdbcCourierRepository.java" />
              <option name="originalContent" value="package com.api.demo.infrastructure.adapter.output.persistence;&#10;&#10;import com.api.demo.domain.model.Courier;&#10;import com.api.demo.domain.model.CourierStatus;&#10;import com.api.demo.domain.port.output.CourierRepository;&#10;import com.api.demo.domain.valueobject.Email;&#10;import com.api.demo.domain.valueobject.Password;&#10;import com.api.demo.domain.valueobject.Phone;&#10;import org.springframework.jdbc.core.JdbcTemplate;&#10;import org.springframework.jdbc.core.RowMapper;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.sql.Timestamp;&#10;import java.time.LocalDateTime;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public class JdbcCourierRepository implements CourierRepository {&#10;&#10;    private final JdbcTemplate jdbcTemplate;&#10;&#10;    public JdbcCourierRepository(JdbcTemplate jdbcTemplate) {&#10;        this.jdbcTemplate = jdbcTemplate;&#10;    }&#10;&#10;    private final RowMapper&lt;Courier&gt; courierRowMapper = (rs, rowNum) -&gt; {&#10;        return new Courier(&#10;            rs.getLong(&quot;id&quot;),&#10;            rs.getString(&quot;name&quot;),&#10;            new Email(rs.getString(&quot;email&quot;)),&#10;            new Phone(rs.getString(&quot;phone&quot;)),&#10;            new Password(rs.getString(&quot;password_hash&quot;)),&#10;            CourierStatus.valueOf(rs.getString(&quot;status&quot;)),&#10;            rs.getTimestamp(&quot;created_at&quot;).toLocalDateTime(),&#10;            rs.getTimestamp(&quot;last_login_at&quot;) != null ?&#10;                rs.getTimestamp(&quot;last_login_at&quot;).toLocalDateTime() : null&#10;        );&#10;    };&#10;&#10;    @Override&#10;    public Optional&lt;Courier&gt; findById(Long id) {&#10;        String sql = &quot;&quot;&quot;&#10;            SELECT id, name, email, phone, password_hash, status, created_at, last_login_at &#10;            FROM couriers &#10;            WHERE id = ?&#10;            &quot;&quot;&quot;;&#10;&#10;        return jdbcTemplate.query(sql, courierRowMapper, id)&#10;                .stream()&#10;                .findFirst();&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;Courier&gt; findByEmail(Email email) {&#10;        String sql = &quot;&quot;&quot;&#10;            SELECT id, name, email, phone, password_hash, status, created_at, last_login_at &#10;            FROM couriers &#10;            WHERE email = ?&#10;            &quot;&quot;&quot;;&#10;&#10;        try {&#10;            return jdbcTemplate.query(sql, courierRowMapper, email.getValue())&#10;                    .stream()&#10;                    .findFirst();&#10;        } catch (Exception e) {&#10;            // Log the error and return empty&#10;            System.err.println(&quot;Error finding courier by email: &quot; + e.getMessage());&#10;            return Optional.empty();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Courier save(Courier courier) {&#10;        if (courier.getId() == null) {&#10;            return insert(courier);&#10;        } else {&#10;            return update(courier);&#10;        }&#10;    }&#10;&#10;    private Courier insert(Courier courier) {&#10;        String sql = &quot;&quot;&quot;&#10;            INSERT INTO couriers (name, email, phone, password_hash, status, created_at) &#10;            VALUES (?, ?, ?, ?, CAST(? AS user_status), ?)&#10;            RETURNING id&#10;            &quot;&quot;&quot;;&#10;&#10;        Long generatedId = jdbcTemplate.queryForObject(sql, Long.class,&#10;            courier.getName(),&#10;            courier.getEmail().getValue(),&#10;            courier.getPhone().getNumber(),&#10;            courier.getPassword().getHashedValue(),&#10;            courier.getStatus().name(),&#10;            Timestamp.valueOf(courier.getCreatedAt())&#10;        );&#10;&#10;        return new Courier(&#10;            generatedId,&#10;            courier.getName(),&#10;            courier.getEmail(),&#10;            courier.getPhone(),&#10;            courier.getPassword(),&#10;            courier.getStatus(),&#10;            courier.getCreatedAt(),&#10;            courier.getLastLoginAt()&#10;        );&#10;    }&#10;&#10;    private Courier update(Courier courier) {&#10;        String sql = &quot;&quot;&quot;&#10;            UPDATE couriers &#10;            SET name = ?, phone = ?, status = ? &#10;            WHERE id = ?&#10;            &quot;&quot;&quot;;&#10;&#10;        jdbcTemplate.update(sql,&#10;            courier.getName(),&#10;            courier.getPhone().getNumber(),&#10;            courier.getStatus().name(),&#10;            courier.getId()&#10;        );&#10;&#10;        return courier;&#10;    }&#10;&#10;    @Override&#10;    public boolean existsByEmail(Email email) {&#10;        String sql = &quot;SELECT COUNT(*) FROM couriers WHERE email = ?&quot;;&#10;        Integer count = jdbcTemplate.queryForObject(sql, Integer.class, email.getValue());&#10;        return count != null &amp;&amp; count &gt; 0;&#10;    }&#10;&#10;    @Override&#10;    public void updateLastLogin(Long courierId) {&#10;        String sql = &quot;UPDATE couriers SET last_login_at = ? WHERE id = ?&quot;;&#10;        jdbcTemplate.update(sql, Timestamp.valueOf(LocalDateTime.now()), courierId);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.api.demo.infrastructure.adapter.output.persistence;&#10;&#10;import com.api.demo.domain.model.Courier;&#10;import com.api.demo.domain.model.CourierStatus;&#10;import com.api.demo.domain.port.output.CourierRepository;&#10;import com.api.demo.domain.valueobject.Email;&#10;import com.api.demo.domain.valueobject.Password;&#10;import com.api.demo.domain.valueobject.Phone;&#10;import org.springframework.jdbc.core.JdbcTemplate;&#10;import org.springframework.jdbc.core.RowMapper;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.sql.Timestamp;&#10;import java.time.LocalDateTime;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public class JdbcCourierRepository implements CourierRepository {&#10;&#10;    private final JdbcTemplate jdbcTemplate;&#10;&#10;    public JdbcCourierRepository(JdbcTemplate jdbcTemplate) {&#10;        this.jdbcTemplate = jdbcTemplate;&#10;    }&#10;&#10;    private final RowMapper&lt;Courier&gt; courierRowMapper = (rs, rowNum) -&gt; {&#10;        return new Courier(&#10;            rs.getLong(&quot;id&quot;),&#10;            rs.getString(&quot;name&quot;),&#10;            new Email(rs.getString(&quot;email&quot;)),&#10;            new Phone(rs.getString(&quot;phone&quot;)),&#10;            new Password(rs.getString(&quot;password_hash&quot;)),&#10;            CourierStatus.valueOf(rs.getString(&quot;status&quot;)),&#10;            rs.getTimestamp(&quot;created_at&quot;).toLocalDateTime(),&#10;            rs.getTimestamp(&quot;last_login_at&quot;) != null ?&#10;                rs.getTimestamp(&quot;last_login_at&quot;).toLocalDateTime() : null&#10;        );&#10;    };&#10;&#10;    @Override&#10;    public Optional&lt;Courier&gt; findById(Long id) {&#10;        String sql = &quot;&quot;&quot;&#10;            SELECT id, name, email, phone, password_hash, status, created_at, last_login_at &#10;            FROM couriers &#10;            WHERE id = ?&#10;            &quot;&quot;&quot;;&#10;&#10;        return jdbcTemplate.query(sql, courierRowMapper, id)&#10;                .stream()&#10;                .findFirst();&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;Courier&gt; findByEmail(Email email) {&#10;        String sql = &quot;&quot;&quot;&#10;            SELECT id, name, email, phone, password_hash, status, created_at, last_login_at &#10;            FROM couriers &#10;            WHERE email = ?&#10;            &quot;&quot;&quot;;&#10;&#10;        try {&#10;            return jdbcTemplate.query(sql, courierRowMapper, email.getValue())&#10;                    .stream()&#10;                    .findFirst();&#10;        } catch (Exception e) {&#10;            // Log the error and return empty&#10;            System.err.println(&quot;Error finding courier by email: &quot; + e.getMessage());&#10;            return Optional.empty();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Courier save(Courier courier) {&#10;        if (courier.getId() == null) {&#10;            return insert(courier);&#10;        } else {&#10;            return update(courier);&#10;        }&#10;    }&#10;&#10;    private Courier insert(Courier courier) {&#10;        String sql = &quot;&quot;&quot;&#10;            INSERT INTO couriers (name, email, phone, password_hash, status, created_at) &#10;            VALUES (?, ?, ?, ?, CAST(? AS user_status), ?)&#10;            RETURNING id&#10;            &quot;&quot;&quot;;&#10;&#10;        Long generatedId = jdbcTemplate.queryForObject(sql, Long.class,&#10;            courier.getName(),&#10;            courier.getEmail().getValue(),&#10;            courier.getPhone().getNumber(),&#10;            courier.getPassword().getHashedValue(),&#10;            courier.getStatus().name(),&#10;            Timestamp.valueOf(courier.getCreatedAt())&#10;        );&#10;&#10;        return new Courier(&#10;            generatedId,&#10;            courier.getName(),&#10;            courier.getEmail(),&#10;            courier.getPhone(),&#10;            courier.getPassword(),&#10;            courier.getStatus(),&#10;            courier.getCreatedAt(),&#10;            courier.getLastLoginAt()&#10;        );&#10;    }&#10;&#10;    private Courier update(Courier courier) {&#10;        String sql = &quot;&quot;&quot;&#10;            UPDATE couriers &#10;            SET name = ?, phone = ?, status = ? &#10;            WHERE id = ?&#10;            &quot;&quot;&quot;;&#10;&#10;        jdbcTemplate.update(sql,&#10;            courier.getName(),&#10;            courier.getPhone().getNumber(),&#10;            courier.getStatus().name(),&#10;            courier.getId()&#10;        );&#10;&#10;        return courier;&#10;    }&#10;&#10;    @Override&#10;    public boolean existsByEmail(Email email) {&#10;        String sql = &quot;SELECT COUNT(*) FROM couriers WHERE email = ?&quot;;&#10;        Integer count = jdbcTemplate.queryForObject(sql, Integer.class, email.getValue());&#10;        return count != null &amp;&amp; count &gt; 0;&#10;    }&#10;&#10;    @Override&#10;    public void updateLastLogin(Long courierId) {&#10;        String sql = &quot;UPDATE couriers SET last_login_at = ? WHERE id = ?&quot;;&#10;        jdbcTemplate.update(sql, Timestamp.valueOf(LocalDateTime.now()), courierId);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/api/demo/security/JwtAccessDeniedHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/api/demo/security/JwtAccessDeniedHandler.java" />
              <option name="updatedContent" value="package com.api.demo.security;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import jakarta.servlet.ServletException;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.servlet.http.HttpServletResponse;&#10;import org.springframework.security.access.AccessDeniedException;&#10;import org.springframework.security.web.access.AccessDeniedHandler;&#10;import org.springframework.stereotype.Component;&#10;&#10;import java.io.IOException;&#10;import java.time.LocalDateTime;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Custom access denied handler to return JSON error responses for 403 Forbidden.&#10; */&#10;@Component&#10;public class JwtAccessDeniedHandler implements AccessDeniedHandler {&#10;&#10;    private final ObjectMapper objectMapper = new ObjectMapper();&#10;&#10;    @Override&#10;    public void handle(HttpServletRequest request,&#10;                       HttpServletResponse response,&#10;                       AccessDeniedException accessDeniedException) throws IOException, ServletException {&#10;        response.setContentType(&quot;application/json;charset=UTF-8&quot;);&#10;        response.setStatus(HttpServletResponse.SC_FORBIDDEN);&#10;&#10;        Map&lt;String, Object&gt; errorResponse = new HashMap&lt;&gt;();&#10;        errorResponse.put(&quot;status&quot;, 403);&#10;        errorResponse.put(&quot;error&quot;, &quot;Forbidden&quot;);&#10;        errorResponse.put(&quot;message&quot;, &quot;Access denied. You do not have permission to access this resource.&quot;);&#10;        errorResponse.put(&quot;path&quot;, request.getRequestURI());&#10;        errorResponse.put(&quot;timestamp&quot;, LocalDateTime.now().toString());&#10;&#10;        response.getWriter().write(objectMapper.writeValueAsString(errorResponse));&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>